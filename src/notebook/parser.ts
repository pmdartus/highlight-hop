import { parse as parseHtml } from "html5parser";
import type { INode, ITag } from "html5parser";

import { findNode, getClassName, isTagNode, getTextContent } from "./utils.ts";
import type {
  BaseMarker,
  Marker,
  MarkerType,
  Note,
  Highlight,
  Notebook,
} from "./types.ts";

/**
 * Parses a HTML notebook generated by the Kindle app into an object.
 */
export function parseNotebook(content: string): Notebook {
  const root = parseHtmlContent(content);
  const notebook = extractMetadataAndMarkers(root.body ?? []);
  const markers = mergeHighlightsAndNotes(notebook.markers);

  return {
    ...notebook,
    markers,
  };
}

/**
 * Parses the HTML content and returns the root container element.
 */
function parseHtmlContent(htmlContent: string): ITag {
  const ast = parseHtml(htmlContent, {
    setAttributeMap: true,
  });

  const html = ast.find((node) => isTagNode(node) && node.name === "html");
  if (!html) {
    throw new Error('Could not find "html" element.');
  }

  const container = findNode(html, (node) => {
    return (
      isTagNode(node) &&
      node.name === "div" &&
      getClassName(node) === "bodyContainer"
    );
  });
  if (!container || !isTagNode(container) || !container.body) {
    throw new Error("Could not locate root container element.");
  }
  return container;
}

/**
 * Extracts metadata and all markers from the HTML content
 */
function extractMetadataAndMarkers(nodes: INode[]): Notebook {
  let title: string | undefined;
  let authors: string | undefined;
  const markers: Marker[] = [];

  let currentSection: string | undefined;
  let currentHeading: SectionHeading | undefined;

  // Filter out non relevant elements
  const elements = nodes.filter(isTagNode);
  for (const elm of elements) {
    const className = getClassName(elm);

    switch (className) {
      // Metadata
      case "notebookFor":
        // Ignore notebookFor
        break;
      case "bookTitle": {
        title = getTextContent(elm);
        break;
      }
      case "authors": {
        authors = getTextContent(elm);
        break;
      }
      case "citation": {
        // Ignore citation
        break;
      }

      case "sectionHeading": {
        currentSection = getTextContent(elm);
        break;
      }

      case "noteHeading": {
        const content = getTextContent(elm);
        const sectionHeading = parseSectionHeading(content);
        if (!sectionHeading) {
          throw new Error("Failed to parse section heading.");
        }

        // Ignore bookmarks
        if (sectionHeading.type === "Bookmark") {
          continue;
        }

        // Set current heading
        currentHeading = sectionHeading;
        break;
      }

      case "noteText": {
        if (!currentHeading) {
          throw new Error("No current heading found.");
        }

        const content = getTextContent(elm);
        const shared: BaseMarker = {
          location: currentHeading.location,
          chapter: currentHeading.chapter,
          page: currentHeading.page,
          section: currentSection,
        };

        if (currentHeading.type === "Highlight") {
          markers.push({
            type: "Highlight",
            color: currentHeading.color!,
            quote: content,
            note: undefined,
            ...shared,
          } satisfies Highlight);
        } else if (currentHeading.type === "Note") {
          markers.push({
            type: "Note",
            note: content,
            ...shared,
          } satisfies Note);
        }

        // Reset current heading
        currentHeading = undefined;
        break;
      }
    }
  }

  if (currentHeading) {
    throw new Error("Unclosed heading found.");
  }

  return { title, authors, markers };
}

/**
 * Post-process raw markers to merge consecutive eligible highlights and notes
 * together.
 */
function mergeHighlightsAndNotes(markers: Marker[]): Marker[] {
  return markers.reduce<Marker[]>((acc, marker) => {
    if (marker.type === "Highlight") {
      acc.push(marker);
    } else if (marker.type === "Note") {
      const lastMarker = acc.at(-1);

      // Assumption: Merge note content with the previous highlight if it
      // exists and if note is empty.
      const shouldMerge =
        lastMarker?.type === "Highlight" && lastMarker?.note === undefined;

      if (shouldMerge) {
        lastMarker.note = marker.note;
      } else {
        acc.push(marker);
      }
    }
    return acc;
  }, []);
}

/**
 * Represents a section heading in the notebook.
 */
interface SectionHeading {
  type: "Bookmark" | "Note" | "Highlight";
  chapter?: string;
  location?: number;
  page?: number;
  color?: string;
}

export function parseSectionHeading(
  content: string,
): SectionHeading | undefined {
  // Extract the section heading type
  const typeMatch = content.match(/^(Highlight|Note|Bookmark)/);
  if (!typeMatch) {
    return undefined;
  }

  const result: SectionHeading = {
    type: typeMatch[1] as MarkerType,
  };

  // Extract highlight color if applicable.
  if (result.type === "Highlight") {
    const colorMatch = content.match(/Highlight\((\w+)\)/);
    result.color = colorMatch?.[1];
  }

  // Extract chapter if present
  const chapterMatch = content.match(/- ([^>]+) >/);
  if (chapterMatch?.[1]) {
    result.chapter = chapterMatch[1].trim();
  }

  // Extract page if present
  const pageMatch = content.match(/Page (\d+)/);
  if (pageMatch?.[1]) {
    result.page = parseInt(pageMatch[1], 10);
  }

  // Extract location
  const locationMatch = content.match(/Location (\d+)/);
  if (locationMatch?.[1]) {
    result.location = parseInt(locationMatch[1], 10);
  }

  return result;
}
